from pingfedsdk.model import Model
from enum import Enum


class EmailServerSettings(Model):
    """Email server configuration settings.

    Attributes
    ----------
    sourceAddr: str
        The email address that appears in the 'From' header line in email messages generated by PingFederate.  The address must be in valid format but need not be set up on your system.

    emailServer: str
        The IP address or hostname of your email server.

    port: int
        The SMTP port on your email server. Allowable values: 1 - 65535. The default value is 25.

    sslPort: int
        The secure SMTP port on your email server. This field is not active unless Use SSL is enabled. Allowable values: 1 - 65535. The default value is  465.

    timeout: int
        The amount of time in seconds that PingFederate will wait before it times out connecting to the SMTP server. Allowable values: 0 - 3600. The default value is 30.

    retryAttempts: int
        The number of times PingFederate tries to resend an email upon unsuccessful delivery. The default value is 2.

    retryDelay: int
        The number of minutes PingFederate waits before the next retry attempt. The default value is 2.

    useSSL: bool
        Requires the use of SSL/TLS on the port specified by 'sslPort'. If this option is enabled, it overrides the 'useTLS' option.

    useTLS: bool
        Requires the use of the STARTTLS protocol on the port specified by 'port'.

    verifyHostname: bool
        If useSSL or useTLS is enabled, this flag determines whether the email server hostname is verified against the server's SMTPS certificate.

    enableUtf8MessageHeaders: bool
        Only set this flag to true if the email server supports UTF-8 characters in message headers. Otherwise, this is defaulted to false.

    useDebugging: bool
        Turns on detailed error messages for the PingFederate server log to help troubleshoot any problems.

    username: str
        Authorized email username. Required if the password is provided.

    password: str
        User password.  To update the password, specify the plaintext value in this field.  This field will not be populated for GET requests.

    encryptedPassword: str
        For GET requests, this field contains the encrypted password, if one exists.  For POST and PUT requests, if you wish to reuse the existing password, this field should be passed back unchanged.

    """

    def __init__(self, emailServer: str, port: int, sourceAddr: str, sslPort: int = None, timeout: int = None, retryAttempts: int = None, retryDelay: int = None, useSSL: bool = None, useTLS: bool = None, verifyHostname: bool = None, enableUtf8MessageHeaders: bool = None, useDebugging: bool = None, username: str = None, password: str = None, encryptedPassword: str = None) -> None:
        self.sourceAddr = sourceAddr
        self.emailServer = emailServer
        self.port = port
        self.sslPort = sslPort
        self.timeout = timeout
        self.retryAttempts = retryAttempts
        self.retryDelay = retryDelay
        self.useSSL = useSSL
        self.useTLS = useTLS
        self.verifyHostname = verifyHostname
        self.enableUtf8MessageHeaders = enableUtf8MessageHeaders
        self.useDebugging = useDebugging
        self.username = username
        self.password = password
        self.encryptedPassword = encryptedPassword

    def _validate(self) -> bool:
        return any(x for x in ["emailServer", "port", "sourceAddr"] if self.__dict__[x] is not None)

    def __eq__(self, other) -> bool:
        if isinstance(other, EmailServerSettings):
            return self.__dict__ == other.__dict__
        return NotImplemented

    def __hash__(self) -> int:
        return hash(frozenset([self.sourceAddr, self.emailServer, self.port, self.sslPort, self.timeout, self.retryAttempts, self.retryDelay, self.useSSL, self.useTLS, self.verifyHostname, self.enableUtf8MessageHeaders, self.useDebugging, self.username, self.password, self.encryptedPassword]))

    @classmethod
    def from_dict(cls, python_dict: dict):
        valid_data = {}
        for k, v in python_dict.items():
            if k in ["sourceAddr", "emailServer", "port", "sslPort", "timeout", "retryAttempts", "retryDelay", "useSSL", "useTLS", "verifyHostname", "enableUtf8MessageHeaders", "useDebugging", "username", "password", "encryptedPassword"] and v is not None:
                if k == "sourceAddr":
                    valid_data[k] = str(v)
                if k == "emailServer":
                    valid_data[k] = str(v)
                if k == "port":
                    valid_data[k] = int(v)
                if k == "sslPort":
                    valid_data[k] = int(v)
                if k == "timeout":
                    valid_data[k] = int(v)
                if k == "retryAttempts":
                    valid_data[k] = int(v)
                if k == "retryDelay":
                    valid_data[k] = int(v)
                if k == "useSSL":
                    valid_data[k] = bool(v)
                if k == "useTLS":
                    valid_data[k] = bool(v)
                if k == "verifyHostname":
                    valid_data[k] = bool(v)
                if k == "enableUtf8MessageHeaders":
                    valid_data[k] = bool(v)
                if k == "useDebugging":
                    valid_data[k] = bool(v)
                if k == "username":
                    valid_data[k] = str(v)
                if k == "password":
                    valid_data[k] = str(v)
                if k == "encryptedPassword":
                    valid_data[k] = str(v)

        return cls(**valid_data)

    def to_dict(self, remove_nonetypes=False):
        """
        Naive dictionary serialiser. Recursively handles most types in this
        module. If you make your own class you need to inherit from model
        and implement to_dict.
        """
        body = {}
        for k, v in self.__dict__.items():
            if k in ["sourceAddr", "emailServer", "port", "sslPort", "timeout", "retryAttempts", "retryDelay", "useSSL", "useTLS", "verifyHostname", "enableUtf8MessageHeaders", "useDebugging", "username", "password", "encryptedPassword"]:
                if isinstance(v, Model):
                    body[k] = v.to_dict(remove_nonetypes)
                elif isinstance(v, list):
                    vals = []
                    for x in v:
                        if isinstance(x, Model):
                            vals.append(x.to_dict(remove_nonetypes))
                        elif not remove_nonetypes or (remove_nonetypes and x is not None):
                            vals.append(x)
                    body[k] = vals
                elif isinstance(v, dict):
                    vals = {}
                    for x, y in v.items():
                        if isinstance(y, Model):
                            vals[x] = y.to_dict(remove_nonetypes)
                        elif not remove_nonetypes or (remove_nonetypes and y is not None):
                            vals[x] = y
                    body[k] = vals
                elif isinstance(v, set):
                    vals = []
                    for x in v:
                        if isinstance(x, Model):
                            vals.append(x.to_dict(remove_nonetypes))
                        elif not remove_nonetypes or (remove_nonetypes and x is not None):
                            vals.append(x)
                    body[k] = vals
                elif isinstance(v, Enum):
                    body[k] = str(v).split('.')[-1]
                elif not remove_nonetypes or (remove_nonetypes and v is not None):
                    body[k] = v
        return body
